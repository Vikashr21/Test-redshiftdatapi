# requirements: boto3, pandas
import os, time
from typing import Any, Dict, List, Optional, Tuple
import concurrent.futures as cf

import boto3
import pandas as pd

# ---- Configure via env or constants ----
WORKGROUP   = os.environ["REDSHIFT_WORKGROUP"]   # e.g., "rs-workgroup-xyz"
DATABASE    = os.environ["REDSHIFT_DATABASE"]    # e.g., "dev"
SECRET_ARN  = os.environ["REDSHIFT_SECRET_ARN"]  # Secrets Manager ARN with DB creds
MAX_CONC    = int(os.getenv("MAX_CONCURRENCY", "6"))
POLL_SECS   = float(os.getenv("POLL_INTERVAL", "0.4"))
STMT_DEADLINE_S = int(os.getenv("STMT_DEADLINE_S", "120"))

rsd = boto3.client("redshift-data")

# ---------- helpers ----------
def _param(name: str, v: Any) -> Dict[str, Any]:
    if v is None:           return {"name": name, "isNull": True}
    if isinstance(v, bool): return {"name": name, "booleanValue": v}
    if isinstance(v, int):  return {"name": name, "longValue": v}
    if isinstance(v, float):return {"name": name, "doubleValue": v}
    return {"name": name, "stringValue": str(v)}

def _cell_val(cell: Dict[str, Any]) -> Any:
    if cell.get("isNull"): return None
    for k in ("longValue","doubleValue","booleanValue","stringValue"):
        if k in cell: return cell[k]
    return None

def _submit(sql: str, params: Optional[Dict[str, Any]] = None) -> str:
    args = dict(WorkgroupName=WORKGROUP, Database=DATABASE, Sql=sql, WithEvent=True)
    if SECRET_ARN: args["SecretArn"] = SECRET_ARN
    if params:     args["Parameters"] = [_param(k, v) for k, v in params.items()]
    return rsd.execute_statement(**args)["Id"]

def _wait(stmt_id: str, deadline_s: int = STMT_DEADLINE_S) -> None:
    t0 = time.time()
    sleep = POLL_SECS
    while True:
        st = rsd.describe_statement(Id=stmt_id)
        s = st["Status"]
        if s in ("FINISHED","FAILED","ABORTED"):
            if s != "FINISHED":
                raise RuntimeError(f"{s}: {st.get('Error')}")
            return
        if time.time() - t0 > deadline_s:
            try: rsd.cancel_statement(Id=stmt_id)
            finally: raise TimeoutError(f"Timed out waiting for {stmt_id}")
        time.sleep(sleep)
        sleep = min(1.0, sleep * 1.2)

def _fetch_all(stmt_id: str) -> Tuple[List[str], List[List[Any]]]:
    cols, rows, token = [], [], None
    while True:
        page = rsd.get_statement_result(Id=stmt_id, NextToken=token) if token else rsd.get_statement_result(Id=stmt_id)
        if not cols:
            cols = [c["name"] for c in page["ColumnMetadata"]]
        for rec in page["Records"]:
            rows.append([_cell_val(c) for c in rec])
        token = page.get("NextToken")
        if not token: break
    return cols, rows

def select_df(sql: str, params: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
    """
    Runs ONE SELECT statement via Data API and returns a pandas DataFrame with column names.
    """
    stmt_id = _submit(sql, params=params)
    _wait(stmt_id)
    cols, rows = _fetch_all(stmt_id)
    return pd.DataFrame(rows, columns=cols)

def run_parallel_selects(jobs: List[Dict[str, Any]], max_concurrency: int = MAX_CONC) -> Dict[str, pd.DataFrame]:
    """
    jobs: list of {"name": str, "sql": str, "params": Optional[dict]}
    returns: {name: DataFrame}
    """
    out: Dict[str, pd.DataFrame] = {}
    def _one(job): return job["name"], select_df(job["sql"], job.get("params"))
    with cf.ThreadPoolExecutor(max_workers=max_concurrency) as pool:
        futs = {pool.submit(_one, j): j for j in jobs}
        for fut in cf.as_completed(futs):
            name, df = fut.result()
            out[name] = df
    return out

# ------------- example -------------
if __name__ == "__main__":
    jobs = [
        {"name": "users_top2", "sql": "SELECT id, name, created_at FROM public.users ORDER BY id LIMIT 2"},
        {"name": "orders_top", "sql": "SELECT user_id, COUNT(*) AS orders FROM public.orders GROUP BY 1 ORDER BY 2 DESC LIMIT 5"},
        {"name": "now",        "sql": "SELECT current_timestamp AS ts_utc"}
    ]
    dfs = run_parallel_selects(jobs, max_concurrency=6)
    for k, v in dfs.items():
        print(f"\n[{k}]")
        print(v)
